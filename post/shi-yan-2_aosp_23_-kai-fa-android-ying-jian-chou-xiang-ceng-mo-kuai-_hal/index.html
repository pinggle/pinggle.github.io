<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>[实验2_aosp]_[2.3_开发Android硬件抽象层模块_HAL] | pinggle的博客</title>
<link rel="shortcut icon" href="https://pinggle.github.io/favicon.ico?v=1739421496780">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://pinggle.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="[实验2_aosp]_[2.3_开发Android硬件抽象层模块_HAL] | pinggle的博客 - Atom Feed" href="https://pinggle.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="2.3，开发Android硬件抽象层模块_动态链接库so
2.3.2，编写硬件抽象层模块接口_编写动态链接库so
硬件抽象层中的模块接口源文件一般保存在: aosp/hardware/libhardware 目录中。我们将虚拟硬件freg在..." />
    <meta name="keywords" content="Android系统源代码情景分析" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://pinggle.github.io">
  <img class="avatar" src="https://pinggle.github.io/images/avatar.png?v=1739421496780" alt="">
  </a>
  <h1 class="site-title">
    pinggle的博客
  </h1>
  <p class="site-description">
    专注，耐心，持之以恒
禁忌: 急躁,贪心
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              [实验2_aosp]_[2.3_开发Android硬件抽象层模块_HAL]
            </h2>
            <div class="post-info">
              <span>
                2025-02-11
              </span>
              <span>
                49 min read
              </span>
              
                <a href="https://pinggle.github.io/tag/fuSoIh1dGr/" class="post-tag">
                  # Android系统源代码情景分析
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h1 id="23开发android硬件抽象层模块_动态链接库so">2.3，开发Android硬件抽象层模块_动态链接库so</h1>
<h2 id="232编写硬件抽象层模块接口_编写动态链接库so">2.3.2，编写硬件抽象层模块接口_编写动态链接库so</h2>
<p>硬件抽象层中的模块接口源文件一般保存在: aosp/hardware/libhardware 目录中。我们将虚拟硬件freg在硬件抽象层中的模块名称定义为freg，目录机构如下：</p>
<pre><code class="language-shell">aosp/hardware/libhardware
----include
    ----hardware
        ----freg.h
modules
    ----freg
        ----freg.cpp
        ----Android.mk
</code></pre>
<p>它由三个文件组成，其中，freg.h 和 freg.cpp 是源代码文件，而 Android.mk 是模块的编译脚本文件。</p>
<h3 id="fregh">freg.h</h3>
<p>文件路径: 2.3.1_r1/hardware/libhardware/include/hardware/freg.h</p>
<pre><code class="language-c">#ifndef ANDROID_FREG_INTERFACE_H
#define ANDROID_FREG_INTERFACE_H

#include &lt;hardware/hardware.h&gt;

__BEGIN_DECLS

/**
 * The id of this module
 * 定义模块ID;
 */
#define FREG_HARDWARE_MODULE_ID &quot;freg&quot;

/**
 * The id of this device
 * 定义设备ID;
 */
#define FREG_HARDWARE_DEVICE_ID &quot;freg&quot;

/* 自定义模块结构体 */
struct freg_module_t {
    struct hw_module_t common;
};

/* 自定义设备结构体 */
struct freg_device_t {
    struct hw_device_t common;
    int fd; // 文件描述符，用来描述打开的设备文件/dev/freg;
    int (*set_val)(struct freg_device_t* dev, int val); // 写虚拟硬件设备freg的寄存器val的内容;
    int (*get_val)(struct freg_device_t* dev, int* val);// 读虚拟硬件设备freg的寄存器val的内容;
};

__END_DECLS

#endif
</code></pre>
<h3 id="fregcpp">freg.cpp</h3>
<p>文件路径: 2.3.1_r1/hardware/libhardware/modules/freg/freg.cpp</p>
<pre><code class="language-c++">#define LOG_TAG &quot;FregHALStub&quot;

#include &lt;hardware/hardware.h&gt;
#include &lt;hardware/freg.h&gt;

#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;

#include &lt;cutils/log.h&gt;
#include &lt;cutils/atomic.h&gt;

#define DEVICE_NAME &quot;/dev/freg&quot;
#define MODULE_NAME &quot;Freg&quot;
#define MODULE_AUTHOR &quot;shyluo@gmail.com&quot;

/* 设备打开和关闭接口 */
static int freg_device_open(const struct hw_module_t* module, const char* id, struct hw_device_t** device);
static int freg_device_close(struct hw_device_t* device);

/* 设备寄存器读写接口 */
static int freg_set_val(struct freg_device_t* dev, int val);
static int freg_get_val(struct freg_device_t* dev, int* val);

/* 定义模块操作方法结构体变量 */
static struct hw_module_methods_t freg_module_methods = {
    open: freg_device_open
};

/* 定义模块结构体变量 */
struct freg_module_t HAL_MODULE_INFO_SYM = {
    common: {
        tag: HARDWARE_MODULE_TAG,  
        version_major: 1,
        version_minor: 0,
        id: FREG_HARDWARE_MODULE_ID,
        name: MODULE_NAME,
        author: MODULE_AUTHOR,
        methods: &amp;freg_module_methods,
    }
};

/* 虚拟硬件设备freg的打开函数 */
static int freg_device_open(const struct hw_module_t* module, const char* id, struct hw_device_t** device) {
    /* 一个硬件抽象层模块可能会包含多个硬件设备，而这些硬件设备根据传递进来的参数id来判断要打开哪一个硬件设备。 */
    if(!strcmp(id, FREG_HARDWARE_DEVICE_ID)) {
        struct freg_device_t* dev;

        /*  为设备分配一个 freg_device_t 结构体，并进行初始化;
            初始化包括虚拟硬件设备freg的关闭函数，读写函数；
        */
        dev = (struct freg_device_t*)malloc(sizeof(struct freg_device_t));
        if(!dev) {
            LOGE(&quot;Failed to alloc space for freg_device_t.&quot;);
            return -EFAULT;
        }

        memset(dev, 0, sizeof(struct freg_device_t));

        dev-&gt;common.tag = HARDWARE_DEVICE_TAG;
        dev-&gt;common.version = 0;
        dev-&gt;common.module = (hw_module_t*)module;
        dev-&gt;common.close = freg_device_close;
        dev-&gt;set_val = freg_set_val;
        dev-&gt;get_val = freg_get_val;
   
        if((dev-&gt;fd = open(DEVICE_NAME, O_RDWR)) == -1) {
            LOGE(&quot;Failed to open device file /dev/freg -- %s.&quot;, strerror(errno));
            free(dev);
            return -EFAULT;
        }

        *device = &amp;(dev-&gt;common);

        LOGI(&quot;Open device file /dev/freg successfully.&quot;);  

        return 0;
    }

    return -EFAULT;
}

/* 虚拟硬件设备freg的关闭函数 */
static int freg_device_close(struct hw_device_t* device) {
    struct freg_device_t* freg_device = (struct freg_device_t*)device;
    if(freg_device) {
        /* 关闭设备文件 /dev/freg, 以及释放设备在打开时所分配的资源; */
        close(freg_device-&gt;fd);
        free(freg_device);
    }

    return 0;
}

/* 虚拟硬件设备freg的写函数，调用write */
static int freg_set_val(struct freg_device_t* dev, int val) {
    if(!dev) {
        LOGE(&quot;Null dev pointer.&quot;);
        return -EFAULT;
    }

    LOGI(&quot;Set value %d to device file /dev/freg.&quot;, val);
    write(dev-&gt;fd, &amp;val, sizeof(val));

    return 0;
}

/* 虚拟硬件设备freg的读函数，调用read */
static int freg_get_val(struct freg_device_t* dev, int* val) {
    if(!dev) {
        LOGE(&quot;Null dev pointer.&quot;);
        return -EFAULT;
    }
   
    if(!val) {
        LOGE(&quot;Null val pointer.&quot;);
        return -EFAULT;
    }

    read(dev-&gt;fd, val, sizeof(*val));

    LOGI(&quot;Get value %d from device file /dev/freg.&quot;, *val);

    return 0;
}
</code></pre>
<h3 id="androidmk">Android.mk</h3>
<p>文件路径: 2.3.1_r1/hardware/libhardware/modules/freg/Android.mk</p>
<pre><code class="language-makefile">LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE_TAGS := optional
LOCAL_PRELINK_MODULE := false
LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
LOCAL_SHARED_LIBRARIES := liblog
LOCAL_SRC_FILES := freg.cpp
LOCAL_MODULE := freg.default
include $(BUILD_SHARED_LIBRARY)
</code></pre>
<p>Android.mk是硬件抽象层模块freg的编译脚本文件，最后一行的include命令参数为: $(BUILD_SHARED_LIBRARY) 表示要将该硬件抽象层模块编译成一个动态链接库文件，名称为 freg.default，并且保存在 $(TARGET_OUT_SHARED_LIBRARIES)/hw 目录下，即 out/target/product/generic/system/lib/hw 目录下。</p>
<h3 id="编译打包">编译&amp;打包</h3>
<pre><code class="language-shell">dt@ubuntu:~/2.3.1_r1$ export PATH=$PATH:/home/dt/2.3.1_r1/out/host/linux-x86/bin
dt@ubuntu:~/2.3.1_r1$ source build/envsetup.sh 
including device/htc/passion/vendorsetup.sh
including device/samsung/crespo/vendorsetup.sh
dt@ubuntu:~/2.3.1_r1$ mmm ./hardware/libhardware/modules/freg

============================================
PLATFORM_VERSION_CODENAME=REL
PLATFORM_VERSION=2.3.1
TARGET_PRODUCT=generic
TARGET_BUILD_VARIANT=eng
TARGET_SIMULATOR=
TARGET_BUILD_TYPE=release
TARGET_BUILD_APPS=
TARGET_ARCH=arm
HOST_ARCH=x86
HOST_OS=linux
HOST_BUILD_TYPE=release
BUILD_ID=GRH78
============================================
make: Entering directory `/home/dt/2.3.1_r1'
target thumb C++: freg.default &lt;= hardware/libhardware/modules/freg/freg.cpp
hardware/libhardware/modules/freg/freg.cpp:40: warning: missing initializer for member 'hw_module_t::dso'
hardware/libhardware/modules/freg/freg.cpp:40: warning: missing initializer for member 'hw_module_t::reserved'
target SharedLib: freg.default (out/target/product/generic/obj/SHARED_LIBRARIES/freg.default_intermediates/LINKED/freg.default.so)
target Non-prelinked: freg.default (out/target/product/generic/symbols/system/lib/hw/freg.default.so)
target Strip: freg.default (out/target/product/generic/obj/lib/freg.default.so)
Install: out/target/product/generic/system/lib/hw/freg.default.so
make: Leaving directory `/home/dt/2.3.1_r1'
</code></pre>
<p>从mmm命令执行的输出信息中，可以看到输出文件为: out/target/product/generic/system/lib/hw/freg.default.so</p>
<h2 id="233硬件抽象层模块的加载过程_分析">2.3.3，硬件抽象层模块的加载过程_分析</h2>
<p>ndroid系统中的硬件层模块是由系统统一加载的，当调用者需要加载这些模块时，只要指定它们的ID值就可以了。在Android硬件抽象层中，负责加载硬件抽象层模块的函数是 hw_get_module，它的原型如下：</p>
<pre><code class="language-C++">// hardware/libhardware/include/hardware/hardware.h

/**
 * Get the module info associated with a module by id.
 * @return: 0 == success, &lt;0 == error and *pHmi == NULL
 */
int hw_get_module(const char *id, const struct hw_module_t **module);

/* hw_get_module 有id和module两个参数，其中，id是输入参数，表示要加载的硬件抽象层模块ID；
  module是输出参数，如果加载成功，那么它指向一个自定义的硬件抽象层模块结构体。函数的返回值是
  一个整数，如果等于0，则表示加载成功；如果小于0，则表示加载失败。
*/
</code></pre>
<h3 id="hw_get_module函数实现">hw_get_module函数实现:</h3>
<pre><code class="language-C++">// hardware/libhardware/hardware.c

/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include &lt;hardware/hardware.h&gt;

#include &lt;cutils/properties.h&gt;

#include &lt;dlfcn.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;
#include &lt;limits.h&gt;

#define LOG_TAG &quot;HAL&quot;
#include &lt;utils/Log.h&gt;

/** Base path of the hal modules */
// 定要要加载的硬件抽象层模块文件所在的目录;（用来保存设备厂商所提供的硬件抽象层模块接口文件）
#define HAL_LIBRARY_PATH1 &quot;/system/lib/hw&quot;
#define HAL_LIBRARY_PATH2 &quot;/vendor/lib/hw&quot;

/**
 * There are a set of variant filename for modules. The form of the filename
 * is &quot;&lt;MODULE_ID&gt;.variant.so&quot; so for the led module the Dream variants
 * of base &quot;ro.product.board&quot;, &quot;ro.board.platform&quot; and &quot;ro.arch&quot; would be:
 *
 * led.trout.so
 * led.msm7k.so
 * led.ARMV6.so
 * led.default.so
 */
// variant_keys 用来组装要加载的硬件抽象层模块的文件名称;
static const char *variant_keys[] = {
    &quot;ro.hardware&quot;,  /* This goes first so that it can pick up a different
                       file on the emulator. */
    &quot;ro.product.board&quot;,
    &quot;ro.board.platform&quot;,
    &quot;ro.arch&quot;
};

// HAL_VARIANT_KEYS_COUNT 表示数组 variant_keys 的大小;
static const int HAL_VARIANT_KEYS_COUNT =
    (sizeof(variant_keys)/sizeof(variant_keys[0]));

/**
 * Load the file defined by the variant and if successful
 * return the dlopen handle and the hmi.
 * @return 0 = success, !0 = failure.
 */
static int load(const char *id,
        const char *path,
        const struct hw_module_t **pHmi)
{
    int status;
    void *handle;
    struct hw_module_t *hmi;

    /*
     * load the symbols resolving undefined symbols before
     * dlopen returns. Since RTLD_GLOBAL is not or'd in with
     * RTLD_NOW the external symbols will not be global
     */
     // 硬件抽象层模块文件实际上是一个动态链接库文件，即so文件;
     // 调用dlopen函数将它加载到内存中;
    handle = dlopen(path, RTLD_NOW);
    if (handle == NULL) {
        char const *err_str = dlerror();
        LOGE(&quot;load: module=%s\n%s&quot;, path, err_str?err_str:&quot;unknown&quot;);
        status = -EINVAL;
        goto done;
    }

    /* Get the address of the struct hal_module_info. */
    const char *sym = HAL_MODULE_INFO_SYM_AS_STR;
    // 使用dlsym函数来获得动态库里面名称为 HAL_MODULE_INFO_SYM_AS_STR 的符号;
    // 这个 HAL_MODULE_INFO_SYM_AS_STR 符号指向的是一个自定义的硬件抽象层模块结构体;
    // 它包含了对应的硬件抽象层模块的所有信息;
    // 下面这行可以安全地将模块中的 HMI 符号转换为一个 hw_module_t 结构体指针;
    hmi = (struct hw_module_t *)dlsym(handle, sym);
    if (hmi == NULL) {
        LOGE(&quot;load: couldn't find symbol %s&quot;, sym);
        status = -EINVAL;
        goto done;
    }

    /* Check that the id matches */
    // 验证加载的硬件抽象层模块ID;
    if (strcmp(id, hmi-&gt;id) != 0) {
        LOGE(&quot;load: id=%s != hmi-&gt;id=%s&quot;, id, hmi-&gt;id);
        status = -EINVAL;
        goto done;
    }

    // 将成功加载后得到的模块句柄值handle保存在 hw_moduel_t 结构体指针 hmi 的成员变量 dso 中;
    hmi-&gt;dso = handle;

    /* success */
    status = 0;

    done:
    if (status != 0) {
        hmi = NULL;
        if (handle != NULL) {
            dlclose(handle);
            handle = NULL;
        }
    } else {
        LOGV(&quot;loaded HAL id=%s path=%s hmi=%p handle=%p&quot;,
                id, path, *pHmi, handle);
    }

    *pHmi = hmi;

    return status;
}

int hw_get_module(const char *id, const struct hw_module_t **module)
{
    int status;
    int i;
    const struct hw_module_t *hmi = NULL;
    char prop[PATH_MAX];
    char path[PATH_MAX];

    /*
     * Here we rely on the fact that calling dlopen multiple times on
     * the same .so will simply increment a refcount (and not load
     * a new copy of the library).
     * We also assume that dlopen() is thread-safe.
     */

    /* Loop through the configuration variants looking for a module */
    // 遍历 HAL_LIBRARY_PATH1 和 HAL_LIBRARY_PATH2 目录中检查对应的硬件抽象层模块文件是否存在;
    for (i=0 ; i&lt;HAL_VARIANT_KEYS_COUNT+1 ; i++) {
        if (i &lt; HAL_VARIANT_KEYS_COUNT) {
            if (property_get(variant_keys[i], prop, NULL) == 0) {
                continue;
            }

            snprintf(path, sizeof(path), &quot;%s/%s.%s.so&quot;,
                    HAL_LIBRARY_PATH1, id, prop);
            if (access(path, R_OK) == 0) break;

            snprintf(path, sizeof(path), &quot;%s/%s.%s.so&quot;,
                     HAL_LIBRARY_PATH2, id, prop);
            if (access(path, R_OK) == 0) break;
        } else {
            snprintf(path, sizeof(path), &quot;%s/%s.default.so&quot;,
                     HAL_LIBRARY_PATH1, id);
            if (access(path, R_OK) == 0) break;
        }
    }

    status = -ENOENT;
    if (i &lt; HAL_VARIANT_KEYS_COUNT+1) {
        /* load the module, if this fails, we're doomed, and we should not try
         * to load a different variant. */
         // 调用load函数来执行加载硬件抽象层模块的操作;
        status = load(id, path, module);
    }

    return status;
}

</code></pre>
<p>硬件抽象层模块文件实际上是一个动态链接库文件，即so文件;</p>
<p>调用dlopen函数将它加载到内存中，使用dlsym函数来获得动态库里面名称为 HAL_MODULE_INFO_SYM_AS_STR 的符号，这个 HAL_MODULE_INFO_SYM_AS_STR 符号指向的是一个自定义的硬件抽象层模块结构体，然后转换为一个 hw_module_t 结构体指针，最后将成功加载后得到的模块句柄值handle保存在 hw_moduel_t 结构体指针 hmi 的成员变量 dso 中;</p>
<h2 id="234处理硬件设备访问权限问题_配置">2.3.4，处理硬件设备访问权限问题_配置</h2>
<p>在默认情况下，只有 root 用户才有权限访问系统的设备文件。由于一般的应用程序是没有 root 用户权限，所以如何赋予 root 之外的其他用户访问设备文件 /dev/freg 权限，就成了一个问题。</p>
<p>在Linux系统中，可以通过 udev 规则在系统启动时修改设备文件的访问权限；在 Android系统中，不是用 udev规则，而是在 system/core/rootdir 目录下有一个 ueventd.rc 的配置文件来配置，我们通过增加如下一行内容来修改设备文件 /dev/freg 的访问权限：</p>
<pre><code class="language-makefile">/dev/freg    0666    root    root
</code></pre>
<p>这表示所有的用户均可以访问设备文件 /dev/freg，即可以打开设备文件 /dev/freg，以及读写它的内容。</p>
<p>在修改该文件后，需要重新编译Android源代码工厂，生成新的 ramdisk.img 镜像文件。</p>
<h1 id="24开发android硬件访问服务_binder服务">2.4，开发Android硬件访问服务_Binder服务</h1>
<p>开发好硬件抽象层模块之后，可以为应用程序提供硬件读写操作。由于硬件抽象层模块是使用C++语言开发的，而应用程序框架层中的硬件访问服务是使用 Java 语言开发的，因此，硬件访问服务必须通过 Java 本地接口（Java Native Interface，JNI）来调用硬件抽象层模块的接口。</p>
<p>Android系统的硬件访问服务通常运行在系统进程 System 中，而使用这些硬件访问服务的应用程序运行在另外的进程中，即应用程序需要通过进程间通信机制来访问这些硬件访问服务。Android中采用 Binder 进程间通信机制，让应用程序能够跨进程访问系统进程System中的硬件访问服务。</p>
<p>Binder 进程间通信机制要求提供服务的一方必须实现一个具有跨进程访问能力的服务接口，以便使用服务的一方可以通过这个服务接口来访问它。因此，在实现硬件访问服务之前，我们首先要定义它的服务接口。</p>
<h2 id="241定义硬件访问服务接口_binder服务接口">2.4.1，定义硬件访问服务接口_Binder服务接口</h2>
<p>binder服务接口，可以理解为跨进程提供的服务接口API声明；</p>
<h3 id="ifregserviceaidl">IFregService.aidl</h3>
<p>文件路径: frameworks/base/core/java/android/os/IFregService.aidl</p>
<pre><code class="language-java">package android.os;

interface IFregService {
    // setVal 用来往虚拟硬件设备freg的寄存器val中写入一个整数;
    void setVal(int val);
    // getVal 用来从虚拟硬件设备freg的寄存器val中读出一个整数;
    int getVal();

}
</code></pre>
<p>aidl 定义的服务接口文件，通过编译脚本文件的声明，在编译时，编译系统会将它们转换成 Java 文件，然后再对它们进行编译。</p>
<p>我们修改编译脚本文件的声明:</p>
<h3 id="androidmk-2">Android.mk</h3>
<p>文件路径: frameworks/base/Android.mk</p>
<p>添加一行，将我们的 IFregService.aidl 文件加入到 LOCAL_SRC_FILES，让编译器识别到。</p>
<pre><code class="language-makefile">LOCAL_SRC_FILES += \
    ......
    core/java/android/os/IRemoteCallback.aidl \
    core/java/android/os/IVibratorService.aidl \
    core/java/android/os/IFregService.aidl \
</code></pre>
<h3 id="编译">编译</h3>
<pre><code class="language-shell">dt@ubuntu:~/2.3.1_r1$ export PATH=$PATH:/home/dt/2.3.1_r1/out/host/linux-x86/bin
dt@ubuntu:~/2.3.1_r1$ source build/envsetup.sh 
including device/htc/passion/vendorsetup.sh
including device/samsung/crespo/vendorsetup.sh
dt@ubuntu:~/2.3.1_r1$ mmm ./frameworks/base/

make: Entering directory `/home/dt/2.3.1_r1`
Aidl: framework &lt;= frameworks/base/core/java/android/os/IFregService.aidl
Copying: out/target/common/obj/JAVA_LIBRARIES/ext_intermediates/emma_out/lib/classes-jarjar.jar
target Java: framework (out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes)
out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/os/IFregService.java:80: warning: unmappable character for encoding ascii
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
100 warnings
Copying: out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes-jarjar.jar
Copying: out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/emma_out/lib/classes-jarjar.jar
Copying: out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar
Copying: out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/noproguard.classes.jar
target Dex: framework
Copying: out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/noproguard.classes.dex
target Jar: framework (out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/javalib.jar)
 'out/target/common/obj/JAVA_LIBRARIES/framework_intermediates//classes.dex' as 'classes.dex'...
Install: out/target/product/generic/system/framework/framework.jar
make: Leaving directory `/home/dt/2.3.1_r1'
</code></pre>
<p>通过编译日志，可以看到输出的java文件为：out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/os/IFregService.java</p>
<h3 id="ifregservicejava_编译自动生成">IFregService.java_编译自动生成</h3>
<p>该文件是编译器依据我们写的IFregService.aidl文件自动生成的，我们打开看看：</p>
<p>文件路径：out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/os/IFregService.java</p>
<pre><code class="language-java">/*
 * This file is auto-generated.  DO NOT MODIFY.
 * Original file: frameworks/base/core/java/android/os/IFregService.aidl
 */
package android.os;

public interface IFregService extends android.os.IInterface {
    /** Local-side IPC implementation stub class. */
    public static abstract class Stub extends android.os.Binder implements android.os.IFregService {
        private static final java.lang.String DESCRIPTOR = &quot;android.os.IFregService&quot;;

        /** Construct the stub at attach it to the interface. */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }

        /**
         * Cast an IBinder object into an android.os.IFregService interface,
         * generating a proxy if needed.
         */
        public static android.os.IFregService asInterface(android.os.IBinder obj) {
            if ((obj == null)) {
                return null;
            }
            android.os.IInterface iin = (android.os.IInterface) obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) &amp;&amp; (iin instanceof android.os.IFregService))) {
                return ((android.os.IFregService) iin);
            }
            return new android.os.IFregService.Stub.Proxy(obj);
        }

        public android.os.IBinder asBinder() {
            return this;
        }

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)
                throws android.os.RemoteException {
            switch (code) {
                case INTERFACE_TRANSACTION: {
                    reply.writeString(DESCRIPTOR);
                    return true;
                }
                case TRANSACTION_setVal: {
                    data.enforceInterface(DESCRIPTOR);
                    int _arg0;
                    _arg0 = data.readInt();
                    this.setVal(_arg0);
                    reply.writeNoException();
                    return true;
                }
                case TRANSACTION_getVal: {
                    data.enforceInterface(DESCRIPTOR);
                    int _result = this.getVal();
                    reply.writeNoException();
                    reply.writeInt(_result);
                    return true;
                }
            }
            return super.onTransact(code, data, reply, flags);
        }

        private static class Proxy implements android.os.IFregService {
            private android.os.IBinder mRemote;

            Proxy(android.os.IBinder remote) {
                mRemote = remote;
            }

            public android.os.IBinder asBinder() {
                return mRemote;
            }

            public java.lang.String getInterfaceDescriptor() {
                return DESCRIPTOR;
            }
            // setVal 用来往虚拟硬件设备freg的寄存器val中写入一个整数;

            public void setVal(int val) throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    _data.writeInt(val);
                    mRemote.transact(Stub.TRANSACTION_setVal, _data, _reply, 0);
                    _reply.readException();
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
            }
            // getVal 用来从虚拟硬件设备freg的寄存器val中读出一个整数;

            public int getVal() throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                int _result;
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    mRemote.transact(Stub.TRANSACTION_getVal, _data, _reply, 0);
                    _reply.readException();
                    _result = _reply.readInt();
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
                return _result;
            }
        }

        static final int TRANSACTION_setVal = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
        static final int TRANSACTION_getVal = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
    }
  
    // setVal 用来往虚拟硬件设备freg的寄存器val中写入一个整数;
    public void setVal(int val) throws android.os.RemoteException;
  
    // getVal 用来从虚拟硬件设备freg的寄存器val中读出一个整数;
    public int getVal() throws android.os.RemoteException;
}
</code></pre>
<p>编译后得到的 framework.jar 文件就包含有 IFregService 接口，它继承了 android.os.IInterface 接口。在 IFregService 接口内部，定义了一个 Binder 本地对象类 Stub，它实现了 IFregService接口，并且继承了 android.os.Binder 类。此外，在 IFregService.Stub 类内部，还定义来一个 Binder 代理对象类 Proxy，它同样也实现了 IFregService 接口。</p>
<p>用 AIDL 定义的服务接口是用来进行进程间通信的，其中，提供服务的进程成为 Server 进程，而使用服务的进程成为 Client 进程。在 Server 进程中，每一个服务都对应有一个 Binder 本地对象，它通过一个桩（ Stub ）来等待 Client 进程发送进程间通信请求。Client 进程在访问运行 Server 进程中的服务之前，首先要获得它的一个 Binder 代理对象（Proxy），然后通过这个 Binder 代理对象接口向它发送进程间通信请求。</p>
<h2 id="242实现硬件访问服务_binder服务java实现类">2.4.2，实现硬件访问服务_Binder服务Java实现类</h2>
<h3 id="fregservicejava">FregService.java</h3>
<p>文件路径：frameworks/base/services/java/com/android/server/FregService.java</p>
<p>硬件访问服务实现类 FregService 从 IFregService.Stub 类继承下来，并且实现 IFregService 接口的成员函数 setVal 和 getVal。</p>
<pre><code class="language-java">package com.android.server;

import android.content.Context;
import android.os.IFregService;
import android.util.Slog;

/* FregService 继承上一步，系统编译AIDL自动生成的抽象类 IFregService.Stub */
public class FregService extends IFregService.Stub {
    private static final String TAG = &quot;FregService&quot;;

    private int mPtr = 0;

    FregService() {
        // 调用 init_native 来打开虚拟硬件设备freg，并获得它的一个句柄值，保存在 mPtr 中;
        mPtr = init_native();

        if (mPtr == 0) {
            // 如果句柄值为0，则判定为打开虚拟硬件设备freg失败;
            Slog.e(TAG, &quot;Failed to initialize freg service.&quot;);
        }
    }

    public void setVal(int val) {
        if (mPtr == 0) {
            Slog.e(TAG, &quot;Freg service is not initialized.&quot;);
            return;
        }

        // 调用 JNI 方法 setVal_native 来写虚拟硬件设备 freg 的寄存器val;
        // 传入 mPtr，即虚拟硬件设备freg的句柄值，确认访问哪一个硬件设备;
        setVal_native(mPtr, val);
    }

    public int getVal() {
        if (mPtr == 0) {
            Slog.e(TAG, &quot;Freg service is not initialized.&quot;);
            return 0;
        }

        // 调用 JNI 方法 getVal_native 来读虚拟硬件设备 freg 的寄存器val;
        // 传入 mPtr，即虚拟硬件设备freg的句柄值，确认访问哪一个硬件设备;
        return getVal_native(mPtr);
    }

    private static native int init_native();

    private static native void setVal_native(int ptr, int val);

    private static native int getVal_native(int ptr);
};
</code></pre>
<h3 id="编译-2">编译</h3>
<pre><code class="language-shell">dt@ubuntu:~/2.3.1_r1$ export PATH=$PATH:/home/dt/2.3.1_r1/out/host/linux-x86/bin
dt@ubuntu:~/2.3.1_r1$ source build/envsetup.sh 
including device/htc/passion/vendorsetup.sh
including device/samsung/crespo/vendorsetup.sh
dt@ubuntu:~/2.3.1_r1$ mmm ./frameworks/base/services/java/

============================================
PLATFORM_VERSION_CODENAME=REL
PLATFORM_VERSION=2.3.1
TARGET_PRODUCT=generic
TARGET_BUILD_VARIANT=eng
TARGET_SIMULATOR=
TARGET_BUILD_TYPE=release
TARGET_BUILD_APPS=
TARGET_ARCH=arm
HOST_ARCH=x86
HOST_OS=linux
HOST_BUILD_TYPE=release
BUILD_ID=GRH78
============================================
make: Entering directory `/home/dt/2.3.1_r1`
target Java: services (out/target/common/obj/JAVA_LIBRARIES/services_intermediates/classes)
frameworks/base/services/java/com/android/server/FregService.java:13: warning: unmappable character for encoding ascii
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
100 warnings
Copying: out/target/common/obj/JAVA_LIBRARIES/services_intermediates/classes-jarjar.jar
Copying: out/target/common/obj/JAVA_LIBRARIES/services_intermediates/emma_out/lib/classes-jarjar.jar
Copying: out/target/common/obj/JAVA_LIBRARIES/services_intermediates/classes.jar
Copying: out/target/common/obj/JAVA_LIBRARIES/services_intermediates/noproguard.classes.jar
target Dex: services
Copying: out/target/common/obj/JAVA_LIBRARIES/services_intermediates/noproguard.classes.dex
target Jar: services (out/target/common/obj/JAVA_LIBRARIES/services_intermediates/javalib.jar)
 'out/target/common/obj/JAVA_LIBRARIES/services_intermediates//classes.dex' as 'classes.dex'...
Install: out/target/product/generic/system/framework/services.jar
make: Leaving directory `/home/dt/2.3.1_r1'
</code></pre>
<p>编译后得到的 service.jar 文件就包含有 FregService 类。</p>
<h2 id="243实现硬件访问服务的jni方法_binder服务c实现">2.4.3，实现硬件访问服务的JNI方法_Binder服务C++实现</h2>
<h3 id="com_android_server_fregservicecpp">com_android_server_FregService.cpp</h3>
<p>文件路径: frameworks/base/services/jni/com_android_server_FregService.cpp</p>
<pre><code class="language-C++">#define LOG_TAG &quot;FregServiceJNI&quot;

#include &quot;jni.h&quot;
#include &quot;JNIHelp.h&quot;
#include &quot;android_runtime/AndroidRuntime.h&quot;

#include &lt;utils/misc.h&gt;
#include &lt;utils/Log.h&gt;
#include &lt;hardware/hardware.h&gt;
#include &lt;hardware/freg.h&gt;

#include &lt;stdio.h&gt;

namespace android
{
    /* 设置虚拟硬件设备freg的寄存器的值 */
    static void freg_setVal(JNIEnv* env, jobject clazz, jint ptr, jint value) {
        /* 将参数ptr转换为 freg_device_t 结构体变量 */
        freg_device_t* device = (freg_device_t*)ptr;
        if(!device) {
            LOGE(&quot;Device freg is not open.&quot;);
            return;
        }
   
        int val = value;

        LOGI(&quot;Set value %d to device freg.&quot;, val);
       
        device-&gt;set_val(device, val);
    }

    /* 读取虚拟硬件设备freg的寄存器的值 */
    static jint freg_getVal(JNIEnv* env, jobject clazz, jint ptr) {
        /* 将参数 ptr 转换为 freg_device_t 结构体变量 */
        freg_device_t* device = (freg_device_t*)ptr;
        if(!device) {
            LOGE(&quot;Device freg is not open.&quot;);
            return 0;
        }

        int val = 0;

        device-&gt;get_val(device, &amp;val);
       
        LOGI(&quot;Get value %d from device freg.&quot;, val);
   
        return val;
    }

    /* 打开虚拟硬件设备freg */
    static inline int freg_device_open(const hw_module_t* module, struct freg_device_t** device) {
        return module-&gt;methods-&gt;open(module, FREG_HARDWARE_DEVICE_ID, (struct hw_device_t**)device);
    }
   
    /* 初始化虚拟硬件设备 freg */
    static jint freg_init(JNIEnv* env, jclass clazz) {
        freg_module_t* module;
        freg_device_t* device;
       
        LOGI(&quot;Initializing HAL stub freg......&quot;);

        /* 加载硬件抽象层模块 freg */
        if(hw_get_module(FREG_HARDWARE_MODULE_ID, (const struct hw_module_t**)&amp;module) == 0) {
            LOGI(&quot;Device freg found.&quot;);
            /* 打开虚拟硬件设备freg */
            if(freg_device_open(&amp;(module-&gt;common), &amp;device) == 0) {
                LOGI(&quot;Device freg is open.&quot;);
                // 获得 freg_device_t 接口，转换成一个整数句柄值，返回;
                return (jint)device;
            }

            LOGE(&quot;Failed to open device freg.&quot;);
            return 0;
        }

        LOGE(&quot;Failed to get HAL stub freg.&quot;);

        return 0;      
    }

    /* Java本地接口方法表 */
    static const JNINativeMethod method_table[] = {
        {&quot;init_native&quot;, &quot;()I&quot;, (void*)freg_init},
        {&quot;setVal_native&quot;, &quot;(II)V&quot;, (void*)freg_setVal},
        {&quot;getVal_native&quot;, &quot;(I)I&quot;, (void*)freg_getVal},
    };

    /* 注册Java本地接口方法 */
    // 该函数需要加入到 onload.cpp 中的 JNI_OnLoad 函数中调用，这样当系统加载时，就将JNI注册到Java虚拟机中;
    int register_android_server_FregService(JNIEnv *env) {
        // jniRegisterNativeMethods 函数把 JNI 方发表 method_table 注册到 Java 虚拟机中，这样 Java 函数就可以调用注册表中的函数了。
        return jniRegisterNativeMethods(env, &quot;com/android/server/FregService&quot;, method_table, NELEM(method_table));
    }
};
</code></pre>
<p>硬件访问服务 FregService 的 JNI 方法（即：com_android_server_FregService.cpp 文件）编写完成之后，我们还需要修改 frameworks/base/services/jni/onload.cpp 文件，在JNI_OnLoad函数里面增加 register_android_server_FregService 函数的调用，这样当系统加载时，就将freg模块的JNI接口注册到Java虚拟机中了。</p>
<h3 id="onloadcpp">onload.cpp</h3>
<p>文件路径：frameworks/base/services/jni/onload.cpp</p>
<pre><code class="language-C++">#include &quot;JNIHelp.h&quot;
#include &quot;jni.h&quot;
#include &quot;utils/Log.h&quot;
#include &quot;utils/misc.h&quot;

namespace android {
    int register_android_server_AlarmManagerService(JNIEnv* env);
    int register_android_server_BatteryService(JNIEnv* env);
    int register_android_server_InputManager(JNIEnv* env);
    int register_android_server_LightsService(JNIEnv* env);
    int register_android_server_PowerManagerService(JNIEnv* env);
    int register_android_server_UsbService(JNIEnv* env);
    int register_android_server_VibratorService(JNIEnv* env);
    int register_android_server_SystemServer(JNIEnv* env);
    int register_android_server_location_GpsLocationProvider(JNIEnv* env);
    // 新增 freg 注册函数的声明;
    int register_android_server_FregService(JNIEnv* env);
};

using namespace android;

extern &quot;C&quot; jint JNI_OnLoad(JavaVM* vm, void* reserved)
{
    JNIEnv* env = NULL;
    jint result = -1;

    if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) {
        LOGE(&quot;GetEnv failed!&quot;);
        return result;
    }
    LOG_ASSERT(env, &quot;Could not retrieve the env!&quot;);

    register_android_server_PowerManagerService(env);
    register_android_server_InputManager(env);
    register_android_server_LightsService(env);
    register_android_server_AlarmManagerService(env);
    register_android_server_BatteryService(env);
    register_android_server_UsbService(env);
    register_android_server_VibratorService(env);
    register_android_server_SystemServer(env);
    register_android_server_location_GpsLocationProvider(env);
    // 新增 freg 注册函数的调用;
    register_android_server_FregService(env);

    return JNI_VERSION_1_4;
}
</code></pre>
<p>onload.cpp 文件实现在 libandroid_servers 模块中。当系统加载 libandroid_servers 模块时，就会调用实现在 onload.cpp 文件中的 JNI_OnLoad 函数。这样，就可以将前面定义的三个 JNI 方法 init_native、setVal_native 和 getVal_native 注册到 Java 虚拟机中。</p>
<p>我们还需要将 com_android_server_FregService.cpp 文件加入到 Android.mk 中，这样编译程序才能找到我们的源文件进行编译。</p>
<h3 id="androidmk-3">Android.mk</h3>
<p>文件路径：frameworks/base/services/jni/Android.mk</p>
<pre><code class="language-makefile">LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)

LOCAL_SRC_FILES:= \
    com_android_server_AlarmManagerService.cpp \
    com_android_server_BatteryService.cpp \
    com_android_server_InputManager.cpp \
    com_android_server_LightsService.cpp \
    com_android_server_PowerManagerService.cpp \
    com_android_server_SystemServer.cpp \
    com_android_server_UsbService.cpp \
    com_android_server_VibratorService.cpp \
    com_android_server_location_GpsLocationProvider.cpp \
    com_android_server_FregService.cpp \
    onload.cpp

LOCAL_C_INCLUDES += \
    $(JNI_H_INCLUDE)

LOCAL_SHARED_LIBRARIES := \
    libandroid_runtime \
    libcutils \
    libhardware \
    libhardware_legacy \
    libnativehelper \
    libsystem_server \
    libutils \
    libui \
    libsurfaceflinger_client

ifeq ($(TARGET_SIMULATOR),true)
ifeq ($(TARGET_OS),linux)
ifeq ($(TARGET_ARCH),x86)
LOCAL_LDLIBS += -lpthread -ldl -lrt
endif
endif
endif

ifeq ($(WITH_MALLOC_LEAK_CHECK),true)
    LOCAL_CFLAGS += -DMALLOC_LEAK_CHECK
endif

LOCAL_MODULE:= libandroid_servers

include $(BUILD_SHARED_LIBRARY)
</code></pre>
<h3 id="编译-3">编译</h3>
<pre><code class="language-shell">dt@ubuntu:~/2.3.1_r1$ export PATH=$PATH:/home/dt/2.3.1_r1/out/host/linux-x86/bin
dt@ubuntu:~/2.3.1_r1$ source build/envsetup.sh 
including device/htc/passion/vendorsetup.sh
including device/samsung/crespo/vendorsetup.sh
dt@ubuntu:~/2.3.1_r1$ mmm ./frameworks/base/services/jni/

============================================
PLATFORM_VERSION_CODENAME=REL
PLATFORM_VERSION=2.3.1
TARGET_PRODUCT=generic
TARGET_BUILD_VARIANT=eng
TARGET_SIMULATOR=
TARGET_BUILD_TYPE=release
TARGET_BUILD_APPS=
TARGET_ARCH=arm
HOST_ARCH=x86
HOST_OS=linux
HOST_BUILD_TYPE=release
BUILD_ID=GRH78
============================================
make: Entering directory `/home/dt/2.3.1_r1`
target thumb C++: libandroid_servers &lt;= frameworks/base/services/jni/com_android_server_FregService.cpp
target thumb C++: libandroid_servers &lt;= frameworks/base/services/jni/onload.cpp
target SharedLib: libandroid_servers (out/target/product/generic/obj/SHARED_LIBRARIES/libandroid_servers_intermediates/LINKED/libandroid_servers.so)
target Prelink: libandroid_servers (out/target/product/generic/symbols/system/lib/libandroid_servers.so)
libelfcopy: Warning: Range lists in .debug_info section aren't in ascending order!
libelfcopy: Warning: Range lists in .debug_ranges section start at 0x68
target Strip: libandroid_servers (out/target/product/generic/obj/lib/libandroid_servers.so)
Install: out/target/product/generic/system/lib/libandroid_servers.so
make: Leaving directory `/home/dt/2.3.1_r1'
</code></pre>
<p>编译后得到的libandroid_servers.so文件就包含有init_native、setVal_native和getVal_native这三个JNI方法了。</p>
<h2 id="244启动硬件访问服务_加入系统服务开机启动">2.4.4，启动硬件访问服务_加入系统服务,开机启动</h2>
<p>Android系统的硬件访问服务通常是在系统进程 System 中启动的，而系统进程 System 是由应用程序孵化器进程 Zygote 负责启动的。由于应用程序孵化器进程 Zygote 是在系统启动时启动的，因此，把硬件访问服务运行在系统进程 System 中，就实现了开机时自动启动。</p>
<p>接下来，我们通过修改 frameworks/base/services/java/com/android/server/SystemServer.java 文件，把我们写的硬件访问服务 FregServer 运行在系统进程 System 中。</p>
<h3 id="systemserverjava">SystemServer.java</h3>
<p>文件路径：frameworks/base/services/java/com/android/server/SystemServer.java</p>
<p>操作：修改 ServerThread 类的成员函数 run 的实现。</p>
<pre><code class="language-java">/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.server;

import com.android.server.am.ActivityManagerService;
import com.android.server.usb.UsbService;
import com.android.internal.app.ShutdownThread;
import com.android.internal.os.BinderInternal;
import com.android.internal.os.SamplingProfilerIntegration;

import dalvik.system.VMRuntime;
import dalvik.system.Zygote;

import android.app.ActivityManagerNative;
import android.bluetooth.BluetoothAdapter;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.ContentService;
import android.content.Context;
import android.content.Intent;
import android.content.pm.IPackageManager;
import android.database.ContentObserver;
import android.database.Cursor;
import android.media.AudioService;
import android.os.Looper;
import android.os.RemoteException;
import android.os.ServiceManager;
import android.os.StrictMode;
import android.os.SystemClock;
import android.os.SystemProperties;
import android.provider.Contacts.People;
import android.provider.Settings;
import android.server.BluetoothA2dpService;
import android.server.BluetoothService;
import android.server.search.SearchManagerService;
import android.util.EventLog;
import android.util.Log;
import android.util.Slog;
import android.accounts.AccountManagerService;

import java.io.File;
import java.util.Timer;
import java.util.TimerTask;

class ServerThread extends Thread {
    private static final String TAG = &quot;SystemServer&quot;;
    private final static boolean INCLUDE_DEMO = false;

    private static final int LOG_BOOT_PROGRESS_SYSTEM_RUN = 3010;

    private ContentResolver mContentResolver;

    private class AdbSettingsObserver extends ContentObserver {
        public AdbSettingsObserver() {
            super(null);
        }

        @Override
        public void onChange(boolean selfChange) {
            boolean enableAdb = (Settings.Secure.getInt(mContentResolver,
                    Settings.Secure.ADB_ENABLED, 0) &gt; 0);
            // setting this secure property will start or stop adbd
            SystemProperties.set(&quot;persist.service.adb.enable&quot;, enableAdb ? &quot;1&quot; : &quot;0&quot;);
        }
    }

    @Override
    public void run() {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN,
                SystemClock.uptimeMillis());

        Looper.prepare();

        android.os.Process.setThreadPriority(
                android.os.Process.THREAD_PRIORITY_FOREGROUND);

        BinderInternal.disableBackgroundScheduling(true);
        android.os.Process.setCanSelfBackground(false);

        // Check whether we failed to shut down last time we tried.
        {
            final String shutdownAction = SystemProperties.get(
                    ShutdownThread.SHUTDOWN_ACTION_PROPERTY, &quot;&quot;);
            if (shutdownAction != null &amp;&amp; shutdownAction.length() &gt; 0) {
                boolean reboot = (shutdownAction.charAt(0) == '1');

                final String reason;
                if (shutdownAction.length() &gt; 1) {
                    reason = shutdownAction.substring(1, shutdownAction.length());
                } else {
                    reason = null;
                }

                ShutdownThread.rebootOrShutdown(reboot, reason);
            }
        }

        String factoryTestStr = SystemProperties.get(&quot;ro.factorytest&quot;);
        int factoryTest = &quot;&quot;.equals(factoryTestStr) ? SystemServer.FACTORY_TEST_OFF
                : Integer.parseInt(factoryTestStr);

        LightsService lights = null;
        PowerManagerService power = null;
        BatteryService battery = null;
        ConnectivityService connectivity = null;
        IPackageManager pm = null;
        Context context = null;
        WindowManagerService wm = null;
        BluetoothService bluetooth = null;
        BluetoothA2dpService bluetoothA2dp = null;
        HeadsetObserver headset = null;
        DockObserver dock = null;
        UsbService usb = null;
        UiModeManagerService uiMode = null;
        RecognitionManagerService recognition = null;
        ThrottleService throttle = null;

        // Critical services...
        try {
            Slog.i(TAG, &quot;Entropy Service&quot;);
            ServiceManager.addService(&quot;entropy&quot;, new EntropyService());

            Slog.i(TAG, &quot;Power Manager&quot;);
            power = new PowerManagerService();
            ServiceManager.addService(Context.POWER_SERVICE, power);

            Slog.i(TAG, &quot;Activity Manager&quot;);
            context = ActivityManagerService.main(factoryTest);

            Slog.i(TAG, &quot;Telephony Registry&quot;);
            ServiceManager.addService(&quot;telephony.registry&quot;, new TelephonyRegistry(context));

            AttributeCache.init(context);

            Slog.i(TAG, &quot;Package Manager&quot;);
            pm = PackageManagerService.main(context,
                    factoryTest != SystemServer.FACTORY_TEST_OFF);

            ActivityManagerService.setSystemProcess();

            mContentResolver = context.getContentResolver();

            // The AccountManager must come before the ContentService
            try {
                Slog.i(TAG, &quot;Account Manager&quot;);
                ServiceManager.addService(Context.ACCOUNT_SERVICE,
                        new AccountManagerService(context));
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting Account Manager&quot;, e);
            }

            Slog.i(TAG, &quot;Content Manager&quot;);
            ContentService.main(context,
                    factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);

            Slog.i(TAG, &quot;System Content Providers&quot;);
            ActivityManagerService.installSystemProviders();

            Slog.i(TAG, &quot;Battery Service&quot;);
            battery = new BatteryService(context);
            ServiceManager.addService(&quot;battery&quot;, battery);

            Slog.i(TAG, &quot;Lights Service&quot;);
            lights = new LightsService(context);

            Slog.i(TAG, &quot;Vibrator Service&quot;);
            ServiceManager.addService(&quot;vibrator&quot;, new VibratorService(context));

            // only initialize the power service after we have started the
            // lights service, content providers and the battery service.
            power.init(context, lights, ActivityManagerService.getDefault(), battery);

            Slog.i(TAG, &quot;Alarm Manager&quot;);
            AlarmManagerService alarm = new AlarmManagerService(context);
            ServiceManager.addService(Context.ALARM_SERVICE, alarm);

            Slog.i(TAG, &quot;Init Watchdog&quot;);
            Watchdog.getInstance().init(context, battery, power, alarm,
                    ActivityManagerService.self());

            Slog.i(TAG, &quot;Window Manager&quot;);
            wm = WindowManagerService.main(context, power,
                    factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL);
            ServiceManager.addService(Context.WINDOW_SERVICE, wm);

            ((ActivityManagerService) ServiceManager.getService(&quot;activity&quot;))
                    .setWindowManager(wm);

            // Skip Bluetooth if we have an emulator kernel
            // TODO: Use a more reliable check to see if this product should
            // support Bluetooth - see bug 988521
            if (SystemProperties.get(&quot;ro.kernel.qemu&quot;).equals(&quot;1&quot;)) {
                Slog.i(TAG, &quot;Registering null Bluetooth Service (emulator)&quot;);
                ServiceManager.addService(BluetoothAdapter.BLUETOOTH_SERVICE, null);
            } else if (factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
                Slog.i(TAG, &quot;Registering null Bluetooth Service (factory test)&quot;);
                ServiceManager.addService(BluetoothAdapter.BLUETOOTH_SERVICE, null);
            } else {
                Slog.i(TAG, &quot;Bluetooth Service&quot;);
                bluetooth = new BluetoothService(context);
                ServiceManager.addService(BluetoothAdapter.BLUETOOTH_SERVICE, bluetooth);
                bluetooth.initAfterRegistration();
                bluetoothA2dp = new BluetoothA2dpService(context, bluetooth);
                ServiceManager.addService(BluetoothA2dpService.BLUETOOTH_A2DP_SERVICE,
                        bluetoothA2dp);

                int bluetoothOn = Settings.Secure.getInt(mContentResolver,
                        Settings.Secure.BLUETOOTH_ON, 0);
                if (bluetoothOn &gt; 0) {
                    bluetooth.enable();
                }
            }

        } catch (RuntimeException e) {
            Slog.e(&quot;System&quot;, &quot;Failure starting core service&quot;, e);
        }

        DevicePolicyManagerService devicePolicy = null;
        StatusBarManagerService statusBar = null;
        InputMethodManagerService imm = null;
        AppWidgetService appWidget = null;
        NotificationManagerService notification = null;
        WallpaperManagerService wallpaper = null;
        LocationManagerService location = null;

        if (factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
            try {
                Slog.i(TAG, &quot;Device Policy&quot;);
                devicePolicy = new DevicePolicyManagerService(context);
                ServiceManager.addService(Context.DEVICE_POLICY_SERVICE, devicePolicy);
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting DevicePolicyService&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;Status Bar&quot;);
                statusBar = new StatusBarManagerService(context);
                ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting StatusBarManagerService&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;Clipboard Service&quot;);
                ServiceManager.addService(Context.CLIPBOARD_SERVICE,
                        new ClipboardService(context));
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting Clipboard Service&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;Input Method Service&quot;);
                imm = new InputMethodManagerService(context, statusBar);
                ServiceManager.addService(Context.INPUT_METHOD_SERVICE, imm);
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting Input Manager Service&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;NetStat Service&quot;);
                ServiceManager.addService(&quot;netstat&quot;, new NetStatService(context));
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting NetStat Service&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;NetworkManagement Service&quot;);
                ServiceManager.addService(
                        Context.NETWORKMANAGEMENT_SERVICE,
                        NetworkManagementService.create(context));
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting NetworkManagement Service&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;Connectivity Service&quot;);
                connectivity = ConnectivityService.getInstance(context);
                ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting Connectivity Service&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;Throttle Service&quot;);
                throttle = new ThrottleService(context);
                ServiceManager.addService(
                        Context.THROTTLE_SERVICE, throttle);
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting ThrottleService&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;Accessibility Manager&quot;);
                ServiceManager.addService(Context.ACCESSIBILITY_SERVICE,
                        new AccessibilityManagerService(context));
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting Accessibility Manager&quot;, e);
            }

            try {
                /*
                 * NotificationManagerService is dependant on MountService,
                 * (for media / usb notifications) so we must start MountService first.
                 */
                Slog.i(TAG, &quot;Mount Service&quot;);
                ServiceManager.addService(&quot;mount&quot;, new MountService(context));
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting Mount Service&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;Notification Manager&quot;);
                notification = new NotificationManagerService(context, statusBar, lights);
                ServiceManager.addService(Context.NOTIFICATION_SERVICE, notification);
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting Notification Manager&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;Device Storage Monitor&quot;);
                ServiceManager.addService(DeviceStorageMonitorService.SERVICE,
                        new DeviceStorageMonitorService(context));
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting DeviceStorageMonitor service&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;Location Manager&quot;);
                location = new LocationManagerService(context);
                ServiceManager.addService(Context.LOCATION_SERVICE, location);
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting Location Manager&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;Search Service&quot;);
                ServiceManager.addService(Context.SEARCH_SERVICE,
                        new SearchManagerService(context));
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting Search Service&quot;, e);
            }

            if (INCLUDE_DEMO) {
                Slog.i(TAG, &quot;Installing demo data...&quot;);
                (new DemoThread(context)).start();
            }

            try {
                Slog.i(TAG, &quot;DropBox Service&quot;);
                ServiceManager.addService(Context.DROPBOX_SERVICE,
                        new DropBoxManagerService(context, new File(&quot;/data/system/dropbox&quot;)));
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting DropBoxManagerService&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;Wallpaper Service&quot;);
                wallpaper = new WallpaperManagerService(context);
                ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting Wallpaper Service&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;Audio Service&quot;);
                ServiceManager.addService(Context.AUDIO_SERVICE, new AudioService(context));
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting Audio Service&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;Headset Observer&quot;);
                // Listen for wired headset changes
                headset = new HeadsetObserver(context);
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting HeadsetObserver&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;Dock Observer&quot;);
                // Listen for dock station changes
                dock = new DockObserver(context, power);
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting DockObserver&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;USB Service&quot;);
                // Listen for USB changes
                usb = new UsbService(context);
                ServiceManager.addService(Context.USB_SERVICE, usb);
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting UsbService&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;UI Mode Manager Service&quot;);
                // Listen for UI mode changes
                uiMode = new UiModeManagerService(context);
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting UiModeManagerService&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;Backup Service&quot;);
                ServiceManager.addService(Context.BACKUP_SERVICE,
                        new BackupManagerService(context));
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting Backup Service&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;AppWidget Service&quot;);
                appWidget = new AppWidgetService(context);
                ServiceManager.addService(Context.APPWIDGET_SERVICE, appWidget);
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting AppWidget Service&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;Recognition Service&quot;);
                recognition = new RecognitionManagerService(context);
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting Recognition Service&quot;, e);
            }

            try {
                Slog.i(TAG, &quot;DiskStats Service&quot;);
                ServiceManager.addService(&quot;diskstats&quot;, new DiskStatsService(context));
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting DiskStats Service&quot;, e);
            }

            // 在这里假如我们写的硬件访问服务FregService;
            try {
                Slog.i(TAG, &quot;Freg Service&quot;);
                ServiceManager.addService(&quot;freg&quot;, new FregService());
            } catch (Throwable e) {
                Slog.e(TAG, &quot;Failure starting Freg Service&quot;, e);
            }
        }

        // make sure the ADB_ENABLED setting value matches the secure property value
        Settings.Secure.putInt(mContentResolver, Settings.Secure.ADB_ENABLED,
                &quot;1&quot;.equals(SystemProperties.get(&quot;persist.service.adb.enable&quot;)) ? 1 : 0);

        // register observer to listen for settings changes
        mContentResolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.ADB_ENABLED),
                false, new AdbSettingsObserver());

        // Before things start rolling, be sure we have decided whether
        // we are in safe mode.
        final boolean safeMode = wm.detectSafeMode();
        if (safeMode) {
            try {
                ActivityManagerNative.getDefault().enterSafeMode();
                // Post the safe mode state in the Zygote class
                Zygote.systemInSafeMode = true;
                // Disable the JIT for the system_server process
                VMRuntime.getRuntime().disableJitCompilation();
            } catch (RemoteException e) {
            }
        } else {
            // Enable the JIT for the system_server process
            VMRuntime.getRuntime().startJitCompilation();
        }

        // It is now time to start up the app processes...

        if (devicePolicy != null) {
            devicePolicy.systemReady();
        }

        if (notification != null) {
            notification.systemReady();
        }

        if (statusBar != null) {
            statusBar.systemReady();
        }
        wm.systemReady();
        power.systemReady();
        try {
            pm.systemReady();
        } catch (RemoteException e) {
        }

        // These are needed to propagate to the runnable below.
        final StatusBarManagerService statusBarF = statusBar;
        final BatteryService batteryF = battery;
        final ConnectivityService connectivityF = connectivity;
        final DockObserver dockF = dock;
        final UsbService usbF = usb;
        final ThrottleService throttleF = throttle;
        final UiModeManagerService uiModeF = uiMode;
        final AppWidgetService appWidgetF = appWidget;
        final WallpaperManagerService wallpaperF = wallpaper;
        final InputMethodManagerService immF = imm;
        final RecognitionManagerService recognitionF = recognition;
        final LocationManagerService locationF = location;

        // We now tell the activity manager it is okay to run third party
        // code. It will call back into us once it has gotten to the state
        // where third party code can really run (but before it has actually
        // started launching the initial applications), for us to complete our
        // initialization.
        ((ActivityManagerService) ActivityManagerNative.getDefault())
                .systemReady(new Runnable() {
                    public void run() {
                        Slog.i(TAG, &quot;Making services ready&quot;);

                        if (statusBarF != null)
                            statusBarF.systemReady2();
                        if (batteryF != null)
                            batteryF.systemReady();
                        if (connectivityF != null)
                            connectivityF.systemReady();
                        if (dockF != null)
                            dockF.systemReady();
                        if (usbF != null)
                            usbF.systemReady();
                        if (uiModeF != null)
                            uiModeF.systemReady();
                        if (recognitionF != null)
                            recognitionF.systemReady();
                        Watchdog.getInstance().start();

                        // It is now okay to let the various system services start their
                        // third party code...

                        if (appWidgetF != null)
                            appWidgetF.systemReady(safeMode);
                        if (wallpaperF != null)
                            wallpaperF.systemReady();
                        if (immF != null)
                            immF.systemReady();
                        if (locationF != null)
                            locationF.systemReady();
                        if (throttleF != null)
                            throttleF.systemReady();
                    }
                });

        // For debug builds, log event loop stalls to dropbox for analysis.
        if (StrictMode.conditionallyEnableDebugLogging()) {
            Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;);
        }

        Looper.loop();
        Slog.d(TAG, &quot;System ServerThread is exiting!&quot;);
    }
}

class DemoThread extends Thread {
    DemoThread(Context context) {
        mContext = context;
    }

    @Override
    public void run() {
        try {
            Cursor c = mContext.getContentResolver().query(People.CONTENT_URI, null, null, null, null);
            boolean hasData = c != null &amp;&amp; c.moveToFirst();
            if (c != null) {
                c.deactivate();
            }
            if (!hasData) {
                DemoDataSet dataset = new DemoDataSet();
                dataset.add(mContext);
            }
        } catch (Throwable e) {
            Slog.e(&quot;SystemServer&quot;, &quot;Failure installing demo data&quot;, e);
        }

    }

    Context mContext;
}

public class SystemServer {
    private static final String TAG = &quot;SystemServer&quot;;

    public static final int FACTORY_TEST_OFF = 0;
    public static final int FACTORY_TEST_LOW_LEVEL = 1;
    public static final int FACTORY_TEST_HIGH_LEVEL = 2;

    static Timer timer;
    static final long SNAPSHOT_INTERVAL = 60 * 60 * 1000; // 1hr

    // The earliest supported time. We pick one day into 1970, to
    // give any timezone code room without going into negative time.
    private static final long EARLIEST_SUPPORTED_TIME = 86400 * 1000;

    /**
     * This method is called from Zygote to initialize the system. This will cause
     * the native
     * services (SurfaceFlinger, AudioFlinger, etc..) to be started. After that it
     * will call back
     * up into init2() to start the Android services.
     */
    native public static void init1(String[] args);

    public static void main(String[] args) {
        if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) {
            // If a device's clock is before 1970 (before 0), a lot of
            // APIs crash dealing with negative numbers, notably
            // java.io.File#setLastModified, so instead we fake it and
            // hope that time from cell towers or NTP fixes it
            // shortly.
            Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;);
            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);
        }

        if (SamplingProfilerIntegration.isEnabled()) {
            SamplingProfilerIntegration.start();
            timer = new Timer();
            timer.schedule(new TimerTask() {
                @Override
                public void run() {
                    SamplingProfilerIntegration.writeSnapshot(&quot;system_server&quot;);
                }
            }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);
        }

        // The system server has to run all of the time, so it needs to be
        // as efficient as possible with its memory usage.
        VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);

        System.loadLibrary(&quot;android_servers&quot;);
        init1(args);
    }

    public static final void init2() {
        Slog.i(TAG, &quot;Entered the Android system server!&quot;);
        Thread thr = new ServerThread();
        thr.setName(&quot;android.server.ServerThread&quot;);
        thr.start();
    }
}
</code></pre>
<p>系统进程 System 在启动时，会创建一个 ServerThread 线程来启动系统中的关键服务，其中就包括一些硬件访问服务。在 ServerThread 类的成员函数 run 中，首先创建一个 FregService 实例，然后把它注册到 Service Manager 中。Service Manager 是 Android 系统的 Binder 进程间通信机制的一个重要角色，它负责管理系统中的服务对象。注册到 Service Manager 中的服务对象都有一个对应的名称，使用这些服务的 Client 进程就是通过这些名称来向 Service Manager 请求它们的 Binder 代理对象接口的，以便可以访问它们所提供的服务。硬件访问服务 FregService 注册到 Service Manager 之后，它的启动过程就完成了。</p>
<h3 id="编译-4">编译</h3>
<pre><code class="language-shell">dt@ubuntu:~/2.3.1_r1$ export PATH=$PATH:/home/dt/2.3.1_r1/out/host/linux-x86/bin
dt@ubuntu:~/2.3.1_r1$ source build/envsetup.sh 
including device/htc/passion/vendorsetup.sh
including device/samsung/crespo/vendorsetup.sh
dt@ubuntu:~/2.3.1_r1$ mmm ./frameworks/base/services/java/

============================================
PLATFORM_VERSION_CODENAME=REL
PLATFORM_VERSION=2.3.1
TARGET_PRODUCT=generic
TARGET_BUILD_VARIANT=eng
TARGET_SIMULATOR=
TARGET_BUILD_TYPE=release
TARGET_BUILD_APPS=
TARGET_ARCH=arm
HOST_ARCH=x86
HOST_OS=linux
HOST_BUILD_TYPE=release
BUILD_ID=GRH78
============================================
make: Entering directory `/home/dt/2.3.1_r1'
target Java: services (out/target/common/obj/JAVA_LIBRARIES/services_intermediates/classes)
frameworks/base/services/java/com/android/server/FregService.java:13: warning: unmappable character for encoding ascii
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
100 warnings
Copying: out/target/common/obj/JAVA_LIBRARIES/services_intermediates/classes-jarjar.jar
Copying: out/target/common/obj/JAVA_LIBRARIES/services_intermediates/emma_out/lib/classes-jarjar.jar
Copying: out/target/common/obj/JAVA_LIBRARIES/services_intermediates/classes.jar
Copying: out/target/common/obj/JAVA_LIBRARIES/services_intermediates/noproguard.classes.jar
target Dex: services
Copying: out/target/common/obj/JAVA_LIBRARIES/services_intermediates/noproguard.classes.dex
target Jar: services (out/target/common/obj/JAVA_LIBRARIES/services_intermediates/javalib.jar)
 'out/target/common/obj/JAVA_LIBRARIES/services_intermediates//classes.dex' as 'classes.dex'...
Install: out/target/product/generic/system/framework/services.jar
make: Leaving directory `/home/dt/2.3.1_r1'
</code></pre>
<p>编译后得到的 services.jar 文件就包含有硬件访问服务 FregService，并且在系统启动时，将它运行在系统进程 System中了。</p>
<p>至此，硬件访问服务 FregService 就完全实现好了。我们可以执行 make snod 命令来重新打包 Android 系统镜像文件 system.img 。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#23%E5%BC%80%E5%8F%91android%E7%A1%AC%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%A8%A1%E5%9D%97_%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93so">2.3，开发Android硬件抽象层模块_动态链接库so</a>
<ul>
<li><a href="#232%E7%BC%96%E5%86%99%E7%A1%AC%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%A8%A1%E5%9D%97%E6%8E%A5%E5%8F%A3_%E7%BC%96%E5%86%99%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93so">2.3.2，编写硬件抽象层模块接口_编写动态链接库so</a>
<ul>
<li><a href="#fregh">freg.h</a></li>
<li><a href="#fregcpp">freg.cpp</a></li>
<li><a href="#androidmk">Android.mk</a></li>
<li><a href="#%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85">编译&amp;打包</a></li>
</ul>
</li>
<li><a href="#233%E7%A1%AC%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B_%E5%88%86%E6%9E%90">2.3.3，硬件抽象层模块的加载过程_分析</a>
<ul>
<li><a href="#hw_get_module%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0">hw_get_module函数实现:</a></li>
</ul>
</li>
<li><a href="#234%E5%A4%84%E7%90%86%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98_%E9%85%8D%E7%BD%AE">2.3.4，处理硬件设备访问权限问题_配置</a></li>
</ul>
</li>
<li><a href="#24%E5%BC%80%E5%8F%91android%E7%A1%AC%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1_binder%E6%9C%8D%E5%8A%A1">2.4，开发Android硬件访问服务_Binder服务</a>
<ul>
<li><a href="#241%E5%AE%9A%E4%B9%89%E7%A1%AC%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3_binder%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3">2.4.1，定义硬件访问服务接口_Binder服务接口</a>
<ul>
<li><a href="#ifregserviceaidl">IFregService.aidl</a></li>
<li><a href="#androidmk-2">Android.mk</a></li>
<li><a href="#%E7%BC%96%E8%AF%91">编译</a></li>
<li><a href="#ifregservicejava_%E7%BC%96%E8%AF%91%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90">IFregService.java_编译自动生成</a></li>
</ul>
</li>
<li><a href="#242%E5%AE%9E%E7%8E%B0%E7%A1%AC%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1_binder%E6%9C%8D%E5%8A%A1java%E5%AE%9E%E7%8E%B0%E7%B1%BB">2.4.2，实现硬件访问服务_Binder服务Java实现类</a>
<ul>
<li><a href="#fregservicejava">FregService.java</a></li>
<li><a href="#%E7%BC%96%E8%AF%91-2">编译</a></li>
</ul>
</li>
<li><a href="#243%E5%AE%9E%E7%8E%B0%E7%A1%AC%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E7%9A%84jni%E6%96%B9%E6%B3%95_binder%E6%9C%8D%E5%8A%A1c%E5%AE%9E%E7%8E%B0">2.4.3，实现硬件访问服务的JNI方法_Binder服务C++实现</a>
<ul>
<li><a href="#com_android_server_fregservicecpp">com_android_server_FregService.cpp</a></li>
<li><a href="#onloadcpp">onload.cpp</a></li>
<li><a href="#androidmk-3">Android.mk</a></li>
<li><a href="#%E7%BC%96%E8%AF%91-3">编译</a></li>
</ul>
</li>
<li><a href="#244%E5%90%AF%E5%8A%A8%E7%A1%AC%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1_%E5%8A%A0%E5%85%A5%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8">2.4.4，启动硬件访问服务_加入系统服务,开机启动</a>
<ul>
<li><a href="#systemserverjava">SystemServer.java</a></li>
<li><a href="#%E7%BC%96%E8%AF%91-4">编译</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://pinggle.github.io/post/shi-yan-1_kernel_21_-kai-fa-android-ying-jian-qu-dong-cheng-xu/">
              <h3 class="post-title">
                [实验1_kernel]_[2.1_开发Android硬件驱动程序_kernel]
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://pinggle.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
